<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle use xml]]></title>
    <url>%2F2019%2F06%2F17%2Foracle-use-xml%2F</url>
    <content type="text"><![CDATA[#说明 ORACLE 本身支持解析XML,这样直接使用oralce处理后台处理业务就比较方便 ##解析示例1 xmltable 12345678910111213141516171819202122232425262728declare rs_msg varchar2(4000); ls_return_xml varchar2(2000); r_ExecuteResult varchar2(200); begin ls_return_xml = &apos;&lt;Result&gt; &lt;Header&gt; &lt;ExecuteResult&gt;False&lt;/ExecuteResult&gt; &lt;Error&gt; &lt;Code&gt;1007&lt;/Code&gt; &lt;Message&gt;错误&lt;/Message&gt; &lt;/Error&gt; &lt;/Header&gt; &lt;Body&gt; &lt;/Body&gt; &lt;/Result&gt;&apos;; SELECT ExecuteResult,Message INTO r_ExecuteResult,rs_msg FROM XMLTABLE(&apos;$B&apos; PASSING XMLTYPE(ls_return_xml) AS B COLUMNS ExecuteResult VARCHAR2(4000) PATH &apos;/Result/Header/ ExecuteResult&apos;, Message varchar2(4000) PATH &apos;/Result/Header/Error/ Message&apos; ); DBMS_OUTPUT.PUT_LINE(r_ExecuteResult); DBMS_OUTPUT.PUT_LINE(rs_msg); end; ##解析示例2 xmldom 还可以使用xmldom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485declare InXMLParam varchar2(4000); --XML解析器 xmlPar XMLPARSER.parser := XMLPARSER.NEWPARSER; --DOM文档对象 doc xmldom.DOMDocument; --节点 PrescriptionNodeList xmldom.DOMNodeList; tempNode_pres xmldom.DOMNode; itemNodes xmldom.DOMNodeList; tempNode xmldom.DOMNode; chilNodes xmldom.DOMNodeList; tempNode_1 xmldom.DOMNode; chilNodes_1 xmldom.DOMNodeList; --以下变量用于获取XML节点的值 PrescriptionLenPres integer; lenItem integer; temp_name varchar2(4000); temp_value varchar2(4000); NodeName varchar2(4000); detail_len integer; BEGIN InXMLParam := &apos;&lt;PrescriptionList&gt; &lt;Prescriptions&gt; &lt;Prescription&gt; &lt;PrescriptionID&gt;9327850&lt;/PrescriptionID&gt; &lt;Invoice_NO&gt;Invoice_NO&lt;/Invoice_NO&gt; &lt;Dispensary&gt;Dispensary&lt;/Dispensary&gt; &lt;EncounterOrganization&gt;急诊科&lt;/EncounterOrganization&gt; &lt;Cost&gt;77.02&lt;/Cost&gt; &lt;Comments&gt;Comments&lt;/Comments&gt; &lt;/Prescription&gt; &lt;Prescription&gt; &lt;PrescriptionID&gt;9327848&lt;/PrescriptionID&gt; &lt;Invoice_NO&gt;Invoice_NO&lt;/Invoice_NO&gt; &lt;Dispensary&gt;Dispensary&lt;/Dispensary&gt; &lt;EncounterOrganization&gt;急诊科&lt;/EncounterOrganization&gt; &lt;Cost&gt;124.06&lt;/Cost&gt; &lt;Comments&gt;Comments&lt;/Comments&gt; &lt;/Prescription&gt; &lt;/Prescriptions&gt; &lt;/PrescriptionList&gt; &apos;; --创建XML解析器 xmlPar := xmlparser.newParser; --装入XML入参 xmlparser.parseBuffer(xmlPar, InXMLParam); --获取Document doc := xmlparser.getDocument(xmlPar); -- 释放解析器实例 xmlparser.freeParser(xmlPar); -- 获取所有 Prescriptions 元素 PrescriptionNodeList := xmldom.getElementsByTagName( doc, &apos;Prescriptions&apos; ); PrescriptionLenPres := xmldom.getLength( PrescriptionNodeList ); -- 遍历所有 Prescriptions 元素 for i in 0..PrescriptionLenPres - 1 loop --获取第i个 Prescription tempNode_pres := xmldom.item( PrescriptionNodeList, i ); itemNodes:= xmldom.getChildNodes(tempNode_pres); lenItem := xmldom.getLength( itemNodes ); --遍历 Prescriptions 下的 所有元素(Prescription) for j in 0..lenItem - 1 loop tempNode := xmldom.item( itemNodes, j ); --获取子元素的值 chilNodes := xmldom.getChildNodes(tempNode); detail_len := xmldom.GETLENGTH( chilNodes ); --遍历 Prescription 下的所有元素 for k in 0..detail_len - 1 loop temp_name := xmldom.getnodename (xmldom.item (chilnodes, k)); temp_value := xmldom.getNodeValue(xmldom.getFirstChild(xmldom.item ( chilNodes, k ))); DBMS_output.PUT_LINE(temp_name||&apos; = &apos;||temp_value); end loop; end loop; end loop; end;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 动态调用存储过程]]></title>
    <url>%2F2019%2F06%2F11%2Foracle-dynamic-procedures%2F</url>
    <content type="text"><![CDATA[统一入参,业务逻辑均在oralce后台包和存储过程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788type声明 CREATE OR REPLACE TYPE &quot;TYPE_TRANS_PARMS&quot; as object ( transcode varchar2(50), --交易代码 transid varchar2(50), --交易流水号 transkey varchar2(50), --系统授权码 transusr varchar2(50), --操 作员 transdev varchar2(50), --设备编码 transhsp varchar2(50), --医院编码 transcmd varchar2(50), --医院编码 transparm type_inparm_array, --交易参数 extraparm1 type_inparm_array, --附加参数1 extraparm2 type_inparm_array --附加参数2 ); --type声明CREATE OR REPLACE TYPE &quot;TYPE_INPARM_ARRAY&quot; declare ll_return pls_integer; ll_count pls_integer; ls_errmsg varchar2(4000); ls_sqlcmd varchar2(4000); ls_trade_no varchar2(100); ls_trade_code varchar2(100); ls_sick_id varchar2(100); ls_parm_in varchar2(4000); g_trans_parms type_trans_parms; arr_in_parm type_inparm_array := type_inparm_array(); extraparm1 type_inparm_array := type_inparm_array(); extraparm2 type_inparm_array := type_inparm_array(); rc_result sys_refcursor; ls_errmsg varchar2(50); ls_trans_no varchar2(50); ls_trans_id varchar2(50); ls_trans_key varchar2(50); ls_trans_usr varchar2(50); ls_trans_dev varchar2(50); ls_trans_hsp varchar2(50); ls_trans_cmd varchar2(50); ls_intrerface varchar2(50); rs_message varchar2(50); begin --interface_common.of_5005 select nvl(cmdtext, &apos;&apos;) into ls_trans_cmd from comm.interface_request_dict where interface = &apos;fdrx&apos; and trade_code = &apos;5005&apos; and valid = &apos;Y&apos;; ls_trans_no := &apos;ls_trans_no&apos;; ls_trans_id := &apos;ls_trans_id&apos;; ls_trans_key := &apos;ls_trans_key&apos;; ls_trans_usr := &apos;ls_trans_usr&apos;; ls_trans_dev := &apos;ls_trans_dev&apos;; ls_trans_hsp := &apos;ls_trans_hsp&apos;; ll_count := 0; while ll_count &lt; 10 loop arr_in_parm.extend; arr_in_parm(arr_in_parm.count) := ll_count; ll_count := ll_count + 1; end loop; g_trans_parms := type_trans_parms(transcode =&gt; ls_trans_no, transid =&gt; ls_trans_id, transkey =&gt; ls_trans_key, transusr =&gt; ls_trans_usr, transdev =&gt; ls_trans_dev, transhsp =&gt; ls_trans_hsp, transcmd =&gt; ls_trans_cmd, transparm =&gt; arr_in_parm, extraparm1 =&gt; extraparm1, extraparm2 =&gt; extraparm2); ls_sqlcmd := lower(g_trans_parms.transcmd); ls_sqlcmd := &apos;begin :1 := &apos; || ls_sqlcmd || &apos;(:2,:3,:4); end;&apos;; execute immediate ls_sqlcmd using out ll_return, in g_trans_parms, in out rs_message, in out rc_result; dbms_output.put_line(rs_message); end;]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加 Git Bash 到右键菜单]]></title>
    <url>%2F2019%2F05%2F31%2Fadd-Git-Bash-to-Right-click%2F</url>
    <content type="text"><![CDATA[因为以前使用工具清理过右键菜单,现在右键没有了Git Bash没有这个右键菜单导致编辑Hexo等的时候切换路径很不方便，所以将这个菜单加出来。 1、win + R，输入“regedit”，回车打开注册表；2、找到 [HKEY_CLASSES_ROOT\Directory\Background]；3、在 [Background] 下如果没有 [shell]，则右键-新建项 [shell]；4、在 [shell] 下右键-新建项[Git Bash Here]，此为右键菜单显示名称；5、在 [Git Bash Here] 下右键-新建-字符串值[Icon],双击编辑，其值为“E:\Git\mingw32\share\git\git-for-windows.ico”。此为菜单加图标，“E:\Git”为安装路径。6、在 [Git Bash Here] 下右键-新建-项[command],修改默认值为 “E:\Git\git-bash.exe”。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用说明]]></title>
    <url>%2F2019%2F05%2F26%2Fgit%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[[TOC] title: Git使用date: 2019-05-26 16:05:50 tags:###参考文献 使用git大部分的内容都是从 廖雪峰的网站获取的,的确称得上是 史上最浅显易懂的Git教程！ 廖雪峰的官方网站 所以此博文最大的用处是做个make. ###使用命令行的Git还是Tortoisegit 以前一直用TortoisegSVN,所以前期用Git的时候就选择了Tortoisegit.虽然这个自带中文操作习惯又一致,但是还是建议掌握命令行的 Git,等上手后再转回Tortoisegit也未尝不可.原因和先手写代码,然后再使用IDE和类一样先打好基础. ###略过部分 12Git简介安装Git ###创建版本库一般我们是在GitHub或者码云上创建版本库再克隆到本地本地创建版本库命令(在git Bash命令行下,先切换到指定目录) 1$ git init ###添加文件 将unit-1.txt纳入版本管理(支持多个一并添加) 1234$ git add &lt;file&gt;示例$ git add unit-1.txt$ git add file2.txt file3.txt ###修改提交(支持多个文件一并处理) 和添加文件命令一致 1234$ git add &lt;file&gt;示例$ git add unit-1.txt$ git add file2.txt file3.txt ###版本提交至缓存区 1$ git commit -m &quot;版本提交说明&quot; ###提交所有修改(注意只会提交已经加入版本库的文件,不会自动添加新文件)$ git commit -a -m “Changed some files” ### ###版本提交日志 12$ git log$ git log-pretty=oneline ###文件回退 1$ git checkout &lt;filename&gt; ###文件删除 1$ git rm &lt;filename&gt; ###版本回退 SHA1的版本号可以不用全部输入.只输入前面部分也可以 1$ git reset --hard commit_id ###git命令历史 1$ git reflog ###为本地库添加远程库 origin 用来表示远程库,支持https和ssh两种方式 12$ git remote add origin https://gitee.com/soft1000_admin/gitBanBenKongZhiXueXi.git$ git remote add origin git@gitee.com:soft1000_admin/gitBanBenKongZhiXueXi.git ###推送远程版本库 1$ git push origin master ###本地克隆版本库 支持https和ssh两种方式 1$ git clone git@gitee.com:soft1000_admin/gitBanBenKongZhiXueXi.git ##分支管理 ###创建分支 1$ git branch 分支名 ###创建+切换分支 1git checkout -b &lt;name&gt; ###查看当前分支 1$ git branch ###切换分支 1$ git checkout 分支名 ###合并分会 1$ git merge 分支名 ###删除分支 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全 1$ git branch -d 分支名]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git-Hexo on Github]]></title>
    <url>%2F2019%2F05%2F26%2Fgit-Hexo-on-Github%2F</url>
    <content type="text"><![CDATA[前言12345使用git作为版本控制好像是目前发展的趋势,越来越多的公司和项目均使用Git作为版本控制。之前一直使用SVN并且还只是使用简单的功能。所以Git学习下，同时又想开个博客把学习的过程包含其他学习内容一并记录下来。也许过程中非常稚嫩但是能一步一步见证自己的成长我觉的 也是一件好事情（Markdown也想学）诸多因素驱动下，发现使用Hexo GIT在Github上开个微 博就能 达成我所有的需求。 参考资料金石开的博文 小茗同学的博客园 准备工作注册一个github账号安装 Git安装了git for windows（或者其它git客户端） 安装node.js 配置Github12345 前面的安装过程略过,配置Github新建一个名为你的用户名.github.io的仓库，比如说，如 果你github用户名是test，那么你就新建 test.github.io 的仓库（必须是你的用户名，其它 名称无效），将来你的网站访问地址就是http://test.github.io每一个github账户最多只能 创建一个这样可以直接使用域名访问的仓库。(这样的好处是 http://test.github.io 打开就 是你的博客了后面可以视个人爱好是否再绑定域名 配置SSH key1配置SSH key是为了提交数据到Github,直接使用用户名和密码不太安全 运行安装好的 git Bash 12345$ cd ~/. ssh #检查本机已存在的ssh密钥 ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件， (例如我的文件目录在 C:\Users\admin\.ssh\id_rsa.pub)记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 将整个pub文件的内容粘贴进去(我一开始想当然只复制了中间部分) 测试是否成功123456$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：You&apos;ve successfully authenticated, but GitHub does not provide shell access.看到这个信息说明SSH已配置成功！ 此时你还需要配置：12$ git config --global user.name &quot;xxx&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 安装Hexo打开Git命令行，执行如下命令1$ npm install -g hexo 3.2 Quick Start123 1. Setup your blog在电脑中建立一个名字叫「Hexo」的文件夹（比如我建在了D:\Hexo），然后在此文件夹中右键打开Git Bash。执行下面的命令 $ hexo init[info] Copying data[info] You are almost done! Don’t forget to run npm install before you start blogging with Hexo!Hexo随后会自动在目标文件夹建立网站所需要的文件。然后按照提示，运行 npm install（在 /D/Hexo下） npm install会在D:\Hexo目录中安装 node_modules。 Start the server 运行下面的命令（在 /D/Hexo下） $ hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.表明Hexo Server已经启动了，在浏览器中打开 http://localhost:4000/，这时可以看到Hexo已为你生成了一篇blog。 你可以按Ctrl+C 停止Server。 Create a new post 新打开一个git bash命令行窗口，cd到/D/Hexo下，执行下面的命令 $ hexo new “My New Post”[info] File created at d:\Hexo\source_posts\My-New-Post.md刷新http://localhost:4000/，可以发现已生成了一篇新文章 “My New Post”。 NOTE： 有一个问题，发现 “My New Post” 被发了2遍，在Hexo server所在的git bash窗口也能看到create了2次。 $ hexo server[info] Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.[create] d:\Hexo\source_posts\My-New-Post.md[create] d:\Hexo\source_posts\My-New-Post.md经验证，在hexo new “My New Post” 时，如果按Ctrl+C将hexo server停掉，就不会出现发2次的问题了。 所以，在hexo new文章时，需要stop server。 Generate static files 执行下面的命令，将markdown文件生成静态网页。 $ hexo generate该命令执行完后，会在 D:\Hexo\public\ 目录下生成一系列html，css等文件。 编辑文章 hexo new “My New Post”会在D:\Hexo\source_posts目录下生成一个markdown文件：My-New-Post.md 可以使用一个支持markdown语法的编辑器（比如 Sublime Text 2）来编辑该文件。 部署到Github 部署到Github前需要配置_config.yml文件，首先找到下面的内容 DeploymentDocs: http://hexo.io/docs/deployment.htmldeploy: type:然后将它们修改为 复制代码 DeploymentDocs: http://hexo.io/docs/deployment.htmldeploy: type: git repository: git@github.com:xxx/xxx.github.io.git branch: master复制代码NOTE1: Repository：必须是SSH形式的url（git@github.com:xxx/xxx.github.io.git），而不能是HTTPS形式的url（https://github.com/xxx/xxx.github.io.git），否则会出现错误： $ hexo deploy[info] Start deploying: github[error] https://github.com/xxx/xxx.github.io is not a valid repositor URL!使用SSH url，如果电脑没有开放SSH 端口，会致部署失败。 fatal: Could not read from remote repository. Please make sure you have the correct access rightsand the repository exists.NOTE2： 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。 测试 当部署完成后，在浏览器中打开http://xxx.github.io/（https://xxx.github.io/） ，正常显示网页，表明部署成功。 总结：部署步骤 每次部署的步骤，可按以下三步来进行。 hexo cleanhexo generatehexo deploy 总结：本地调试 在执行下面的命令后， $ hexo g #生成$ hexo s #启动本地服务，进行文章预览调试浏览器输入http://localhost:4000，查看搭建效果。此后的每次变更_config.yml 文件或者新建文件都可以先用此命令调试，尤其是当你想调试新添加的主题时。 可以用简化的一条命令 hexo s -g3.3 命令总结3.3.1 常用命令复制代码hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本复制代码3.3.2 复合命令hexo deploy -g #生成加部署hexo server -g #生成加预览命令的简写为： hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
